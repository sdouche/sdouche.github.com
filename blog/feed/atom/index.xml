<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Ruminations From a Tortured Mind</title>
  <subtitle type="text">Me me me me</subtitle>

  <updated>2012-12-17T11:46:31Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://douche.name/blog" />
  <id>http://douche.name/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://douche.name/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://douche.name/blog</uri>
    </author>
    <title type="html"><![CDATA[Catalogue formation 2013]]></title>
    <link rel="alternate" type="text/html" href="http://douche.name/blog/2012/12/17/catalogue-formation-2013" />
    <id>http://douche.name/blog/2012/12/17/catalogue-formation-2013</id>
    <updated>2012-12-17T12:44:00Z</updated>
    <published>2012-12-17T12:44:00Z</published>
    <category scheme="http://douche.name/blog" term="formation" />
    <summary type="html"><![CDATA[Catalogue formation 2013]]></summary>
    <content type="html" xml:base="http://douche.name/blog/2012/12/17/catalogue-formation-2013"><![CDATA[<p>En septembre 2010, j'ai lancé #gitfr pour expliquer les DVCS et Git en
particulier. 2 ans, ~30 présentations et ~10 ateliers plus tard j'ai besoin de
parler d'autres choses :). Je propose de nouveaux ateliers et présentations sur
des sujets assez variés, que ce soit en développement, administration ou
management. Si vous êtes interéssé par un sujet, il suffit de me contacter pour
se mettre d'accord sur un lieu et une date.</p>
<p><strong>Attention</strong> : Je n'ai aucune certification, je ne suis pas estampillé
«Expert machin» ou «Champion truc». Je n'ai même jamais eu de formation sur un
quelconque sujet (j'ai appris la plupart du temps seul dans mon coin dans le
cadre professionnel).  Ce ne sont que des <strong>modestes retours d'expérience</strong> sur
des sujets qui m'intéressent et que je souhaite partager.</p>
<p>Comme pour #gitfr, le deal est le suivant :</p>
<ul>
<li>C'est <strong>gratuit</strong> (je demande juste le remboursement des frais de transport
  et d'hébergement) dans le cadre d'une action associative.</li>
<li>La gestion de l'événement est à votre charge (trouver un lieu, accueillir les
  gens, etc).</li>
<li>Etant un utilisateur de Logiciels Libres depuis plus de 15 ans, je me
  focalise que sur les plateformes <strong>Linux / BSD</strong>. Les OS «professionnels» ne
  m'intéresse pas, ni de prêt ni de loin.</li>
</ul>
<p>Certains ateliers sont plutôt bien avancés, d'autres n'existent que dans ma tête.
Ne vous étonnez donc pas si je vous réponds qu'il me faut plusieurs mois pour
en préparer certains :). J'ai mis une petite présentation sans prétention pour
chaque sujet (la plupart sont à l'état de brouillon) pour vous donner un aperçu
du contenu et de l'objectif recherché. Les durées sont des estimations à la
louche, ne vous focalisez pas trop dessus.</p>
<p><strong>Note 1</strong> : Cette page devrait évoluer, n'hésitez donc pas à venir de temps en
temps.</p>
<p><strong>Note 2</strong> : Chaque atelier peut évidemment être transformé en présentation
si c'est ce format que vous recherchez. De même, si le sujet vous intéresse
mais qu'il manque un contenu particulier, n'hésitez pas à en faire la
demande.</p>
<p><strong>Note 3</strong> : j'ai mis à la fin des idées de sujet. Si vous avez d'autres, 
postez un commentaire. Si j'ai les compétences nécessaires, je tenterai
d'en faire quelque chose.</p>
<h2>Introduction à la virtualisation</h2>
<p><strong>Domaine</strong> : infra / <strong>Type</strong> : atelier  / <strong>Durée</strong>: : 5h</p>
<p>La virtualisation offre de nombreux avantages, autant pour le développeur qui
peut tester facilement et sans danger son code que pour l'administrateur qui
peut gérer une infrastructure avec beaucoup moins de machines.</p>
<p>Objectif :</p>
<ul>
<li>Comprendre les différentes techno de virtualisation</li>
<li>Apprendre à créer des machines virtualisées</li>
<li>Déployer une infrastructure virtualisée</li>
<li>Distribuer des VMs</li>
</ul>
<p>Contenu :</p>
<ul>
<li>QEMU / KVM</li>
<li>LXC</li>
<li>VirtualBox</li>
<li>OpenVZ ?</li>
<li>Xen ?</li>
<li>Apprentissage des formats d'image (RAW, VDI, QCOW2, VMDK)</li>
<li>Apprentissage du format de description OVF</li>
<li>Libvirt</li>
<li>Virt-tools</li>
<li>Guestfs et sa suite d'outils</li>
</ul>
<p><strong>Note</strong> : L'atelier se focalise principalement sur la techo KVM qui devient la
référence dans le monde du Libre. Je rajoute LXC qui est simple et pratique. Je
ne suis pas sûr pour OpenVZ et Xen.</p>
<h2>Monter son cloud avec OpenStack</h2>
<p><strong>Domaine</strong> : infra / <strong>Type</strong> : atelier  / <strong>Durée</strong>: : 5h</p>
<p>Si Amazon AWS est la référence du cloud, il peut être plus intéressant de
disposer d'une technologie que l'on maitrise de bout en bout, que ce soit pour
monter un cloud privé ou public. Le projet OpenStack, monté par Rackspace et
dirigé maintenant par une organisation mondiale composée de dizaines de
société, est devenu la technologie cloud Libre la plus en vue.</p>
<p>Objectif :</p>
<ul>
<li>Comprendre l'architecture OpenStack</li>
<li>Installation et configuration</li>
<li>Déployer une VM</li>
</ul>
<h2>Gérer son cloud Amazon AWS en Python</h2>
<p><strong>Domaine</strong> : infra / <strong>Type</strong> : atelier  / <strong>Durée</strong>: : 3h</p>
<p>Aprés une rapide introduction au Cloud IAAS, nous verrons comment en partant de
zéro, mettre en place des machines virtuelles sur Amazon AWS et les exploiter
avec Boto et SaltCloud.</p>
<p>Objectif :</p>
<ul>
<li>Déployer ses propres images sur le cloud Amazon</li>
</ul>
<p>Contenu :</p>
<ul>
<li>Présentation rapide d'Amazon AWS</li>
<li>Créer une image Amazon</li>
<li>Déployer avec Boto</li>
<li>Déployer avec SaltCloud</li>
</ul>
<h2>La virtualisation du réseau</h2>
<p><strong>Domaine</strong> : infra / <strong>Type</strong> : atelier  / <strong>Durée</strong>: : 3h</p>
<p>Après le IAAS, le PAAS et la SASS, voici le NAAS (Network As A Service). Si
la virtualisation de vos machines est un pas en avant, il manque un élément :
la capacité de gérer aisèment votre réseau qui alimente vos machines
virtualisées. Venez découvrir dans cet atelier OpenVSwitch, la référence
Libre dans le domaine.</p>
<p>Objectif :</p>
<ul>
<li>Comprendre l'architecture OpenVSwtich</li>
<li>Déployer un switch virtuel</li>
</ul>
<p>Contenu : </p>
<ul>
<li>Introduction à la virtualisation réseau</li>
<li>OpenFlow et contrôle automatisé</li>
<li>Installation</li>
<li>Configuration de base</li>
<li>Monitoring : Netflow, sFlow, SPAN, RSPAN</li>
<li>QoS</li>
<li>Modification à la volée de paquets</li>
<li>gestion de VLAN</li>
<li>Contrôle de votre réseau avec POX / MOX</li>
</ul>
<h2>Sécuriser votre réseau avec PF</h2>
<p><strong>Domaine</strong> : infra / <strong>Type</strong> : atelier  / <strong>Durée</strong>: : 3h</p>
<p>Trop souvent, les sociétés ne mettent pas de firewall ou utilisent ceux
intégrés à des produits comme les routeurs Internet. Et quand ils en mettent
un, ce sont des technos propriétaires lourdes. Pourtant, OpenBSD à créer
le pare-feu PF, très simple de mise en place (surtout comparé à son équivalent
Linux Iptables) et agréable d'utilisation. Avec PF, la sécurisation est un jeu
d'enfant.</p>
<p>Objectif :</p>
<ul>
<li>Comprendre PF</li>
<li>Déployer un pare-feu</li>
</ul>
<p>Contenu :</p>
<ul>
<li>Introduction à la sécurité des réseaux</li>
<li>Les différents modèles de PF</li>
<li>Installation d'OpenBSD</li>
<li>Configuration PF simple pour un petit réseau</li>
<li>Configuration PF simple pour un réseau élaboré</li>
<li>Configuration PF avancée pour un réseau élaboré</li>
<li>Mise en place du QOS</li>
<li>Supervision de son pare-feu</li>
</ul>
<p><strong>Note</strong> : L'utilisation d'un live-CD est envisagée pour sauter l'étape
installation.</p>
<h2>Développer des scripts en Python</h2>
<p><strong>Domaine</strong> : développement / <strong>Type</strong> : atelier  / <strong>Durée</strong>: : 5h</p>
<p>Vous écrivez encore vos scripts en Shell à base de cut, grep, awk ? Vous
souffrez pour les maintenir quand ils dépassent 100 lignes ? Venez découvrir
le langage Python qui vous offre l'accès à de nombreuses librairies pour
coder des scripts systèmes allié à une maintenance bien plus aisée.</p>
<p>Objectif :</p>
<ul>
<li>Apprendre les bases de Python</li>
<li>Ecrire de petits programmes (système, graphique, réseau)</li>
</ul>
<p>Contenu : </p>
<ul>
<li>Installation de Python</li>
<li>Premiers pas (variable, affectation, opérateur, expression)</li>
<li>Contrôle du flux d'exécution</li>
<li>Principaux types de données</li>
<li>Les fonctions</li>
<li>Approfondir les structures de données</li>
<li>La programmation objet en Python</li>
<li>Maitriser les outils de base : pip, virtualenv</li>
<li>Introduction à l'outil Buildout</li>
<li>La sémentique Python</li>
<li>Apprentissage de  quelques modules importants</li>
<li>Etude de quelques librairies intéressantes</li>
<li>Débugger du code Python</li>
<li>Comprendre le packaging Python</li>
</ul>
<h2>Maitriser le packaging Python</h2>
<p><strong>Domaine</strong> : développement / <strong>Type</strong> : atelier  / <strong>Durée</strong>: : 3h</p>
<p>Distutils, Setuptools, format source, binaire ou Egg, easy-install, pip,
distribute, PyPI... Êtes vous perdu ? Si ces mots vous sont inconnus ou vous
donnent mal au crane, cette session est donc pour vous. Des premiers pas
jusqu'à la diffusion de vos programmes, cette session vous aide dans vos
premiers pas dans le monde Python.</p>
<p>Objectif :</p>
<ul>
<li>Comprendre le packaging Python</li>
<li>Maitriser son environnement de travail</li>
<li>Savoir distribuer ses programmes Python</li>
</ul>
<p>Contenu :</p>
<ul>
<li>Décortiquer le packaging Python (distutils, distribute)</li>
<li>Outil PIP</li>
<li>Outil Buildout</li>
</ul>
<h2>Gérer sa documentation avec Sphinx</h2>
<p><strong>Domaine</strong> : infra / <strong>Type</strong> : atelier  / <strong>Durée</strong>: : 1.5h</p>
<p>LibreOffice ou Word pour écrire et maintenir de la documentation, c'est la
plaie ! Développé originalement pour la documentation officielle Python, Sphinx
vous permet de créer une documentation HTML, PDF ou EPUB simplement et surtout
maintenable puisque tout est sous forme de fichier texte. Il devient alors
possible de gérer sa documentation comme on le fait pour son code : utilisation
du DVCS, revue des pairs, etc.</p>
<p>Objectif :</p>
<ul>
<li>Créer une documentation HTML et PDF</li>
</ul>
<h2>Infra : Gérer son parc machine avec Salt</h2>
<p><strong>Domaine</strong> : infra / <strong>Type</strong> : atelier  / <strong>Durée</strong>: : 2h</p>
<p>Si vous entendez souvent parler de Puppet et Chef, ce n'est pas le cas d'un
nouveau venu qui se nomme Salt. Intégrant un shell distribué, rapide, facile
d'utilisation et aisèment extensible en Python, Salt facilite gradement la
gestion de votre parc de machines.</p>
<p>Objectif :</p>
<ul>
<li>Comprendre l'architecture Salt</li>
<li>Contrôler une machine virtualisée</li>
</ul>
<p>Contenu :</p>
<ul>
<li>Installation</li>
<li>Configuration basique</li>
<li>Utiliser quelques modules Salt</li>
<li>Apprendre à coder un module Salt</li>
<li>Salt pour le cloud</li>
</ul>
<h2>Présentation du langage Go</h2>
<p><strong>Domaine</strong> : développement / <strong>Type</strong> : présentation  / <strong>Durée</strong>: : 1.5h</p>
<p>La version 1.0 de Go est sortie début 2012. Pourquoi apprendre Go et non Nodejs
ou Erlang ? Qu'apporte t'il par rapport à Python, Ruby ou PHP ? L'objectif de
cette session est de faire le tour de ce langage et de montrer concrétement son
positionnement ainsi ses avantages et incovénients.</p>
<p>Objectif :</p>
<ul>
<li>Positionner Go par rapport aux autres langages</li>
<li>Comprendre le modèle objet de Go</li>
<li>Voir l'apport de Go dans la programmation concurrente</li>
</ul>
<h2>Atelier Go</h2>
<p><strong>Domaine</strong> : développement / <strong>Type</strong> : atelier / <strong>Durée</strong>: : 5h</p>
<p>Vous êtes curieux de voir ce que donne ce langage mais vous n'avez jamais
osé coder ? Voici un atelier pour s'initier.</p>
<p>Objectif :</p>
<ul>
<li>Coder quelques scripts système</li>
<li>Coder un service réseau concurrent</li>
</ul>
<p>Contenu : </p>
<ul>
<li>Installation de Go</li>
<li>Structuration d'un projet</li>
<li>Types de base (boolean, int, string)</li>
<li>Types collection (array, slice, map)</li>
<li>Programmation procédurale (if, switch, for)</li>
<li>Les fonctions</li>
<li>Gestion des erreurs</li>
<li>Programmation orienté objet en Go (custom type, interface, struct)</li>
<li>Visite de la librairie standard</li>
<li>Channel et goroutine</li>
<li>Programmation parallèle</li>
<li>Test unitaire</li>
<li>Debuggage d'un code Go</li>
<li>Installation d'un package</li>
<li>Création d'un package</li>
<li>Déploiement d'un projet Go</li>
</ul>
<h2>Présentation du langage Dart</h2>
<p><strong>Domaine</strong> : développement / <strong>Type</strong> : présentation  / <strong>Durée</strong>: : 1.5h</p>
<p>Développé d'abord comme un projet de R&amp;D par une partie de l'équipe v8, Dart
est annoncé le 10 octobre 2011 par Google comme un nouveau langage pour le
web.</p>
<p>La version 1.0 de Go est sortie début 2012. Pourquoi apprendre Go et non Nodejs
ou Erlang ? Qu'apporte t'il par rapport à Python, Ruby ou PHP ? L'objectif de
cette session est de faire le tour de ce langage et de montrer concrétement son
positionnement ainsi ses avantages et incovénients.</p>
<p>Objectif :</p>
<ul>
<li>Positionner Dart par rapport à Javascript</li>
<li>Montrer comment Dart modifie la façon de développer un site web</li>
</ul>
<p><strong>Note</strong> : Pas avant la sortie de Dart 1.0.</p>
<h2>Atelier Dart</h2>
<p><strong>Domaine</strong> : développement / <strong>Type</strong> : atelier / <strong>Durée</strong>: : 5h</p>
<p>Vous êtes curieux de voir ce que donne ce langage mais vous n'avez jamais
osé coder ? Voici un atelier pour s'initier.</p>
<p>Objectif :</p>
<ul>
<li>Coder une page dynamique (one page website)</li>
</ul>
<p>Contenu : </p>
<ul>
<li>Installation de Dart</li>
<li>1er programme en ligne de commande</li>
<li>Vérification avec dart-analyser</li>
<li>Découverte de l'éditeur Dart</li>
<li>Dart natif et Dart2js</li>
<li>Architecture d'application web une page</li>
<li>Types de base (number, string, boolean, list, map)</li>
<li>Programmation procédurale (if, while, do while, switch, for)</li>
<li>Accéder au DOM (dart:html)</li>
<li>Fonction et closure</li>
<li>Gestion des erreurs</li>
<li>Programmation orienté objet en Dart (classe, interface)</li>
<li>Generics</li>
<li>Librairie et visibilité</li>
<li>Programmation concurrente (isolate)</li>
<li>Organiser son code Dart</li>
<li>Gestion de package avec pub</li>
<li>Programmation asynchrone</li>
<li>Développement d'une application Dart coté client</li>
<li>Développement d'une application Dart coté serveur</li>
<li>"Web component"</li>
<li>Test unitaire et Mock</li>
<li>Debuggage d'un code Dart</li>
<li>Installation d'un package</li>
<li>Création d'un package</li>
<li>Déploiement d'un projet Dart</li>
</ul>
<p><strong>Note</strong> : Pas avant la sortie de Dart 1.0.</p>
<h2>Retour d'expérience sur le deploiement continue</h2>
<p><strong>Domaine</strong> : management / <strong>Type</strong> : présentation  / <strong>Durée</strong>: : 1.5h</p>
<p>L'intégration continue est considérée depuis plusieurs années comme une bonne
pratique de gestion de projet, et sa généralisation dans les équipes de
développement est une avancée notable. Mais pour s'assurer que son produit
fonctione, rien ne vaut un déploiement dans un environnement réaliste. D'ou
l'émergence d'une nouvelle pratique : le déploiement continue. Cette session
est un retour d'expérience de 3 ans de cette pratique chez un éditeur logiciel.
Nous parlerons d'outil d'intégration continue et de virtualisation ainsi que
d'outil de gestion de source. Nous aborderons aussi la philosophie Devops dont
cette pratique est en droite ligne.</p>
<h2>Retour d'expérience sur la revue de code</h2>
<p><strong>Domaine</strong> : management / <strong>Type</strong> : présentation  / <strong>Durée</strong>: : 1.5h</p>
<p>Depuis 3 ans, nous pratiquons la revue de code systématique, chaque ligne de
code (ainsi que l'infra ou le packaging) étant revue avant de passer en
production. Coûteuse en temps, elle permet néanmoins d'augmenter la qualité en
trouvant erreurs et bugs potentiels. Mais surtout, elle permet d'aligner
l'équipe autour de pratiques communes, en normalisant le code et en échangeant
ses connaissances. Cette session est un retour d'expérience de ces années de
pratique : comment mettre en place la revue de code ? Quelles sont les
différentes façons de faire de la revue ? Quel mentalité doit on avoir ?
quelles sont les avantages et inconvénients ? Les bonnes pratiques et les
erreurs à éviter ? Nous passerons également en revue deux Logiciels Libres pour
mettre en place la revue de code : ReviewBoard et Gerrit.</p>
<h2>Simplifier vous la vie avec Buildout (Python)</h2>
<p><strong>Domaine</strong> : dev / <strong>Type</strong> : atelier  / <strong>Durée</strong>: : 3h</p>
<p>Une difficulté quand on travaille en équipe est d'avoir un environnement
parfaitement identique et répétable, surtout qu'on possède beaucoup de
composants Python. Il faut bricoler un environnement virtuel, installer les
bonnes versions de chaque composant et modifier le sys.path à la main pour
utiliser ses composants en cours de développement. Et les choses se complique
quand il est nécessaire de disposer des logiciels non Python. Certains
développeurs utilisent l'outil Virtualenv associé à l'outil PIP. Mais il existe
pourtant un outil bien plus puissant et adapté : Buildout. Sous une doc austère
se cache un outil puissant et efficace, et relativement simple d'utilisation
qui permet de reproduire rapidement et efficacement un environnement donné,
grace notamment à un système de plug-ins (appelé recettes). L'objectif de cette
session est de vous rendre autonome sur l'outil et d'apporter en plus un retour
d'expérience de 4 ans d'utilisation chez un éditeur logiciel où il est utilisé
en sus comme outil de déploiement. Nous aborderons aussi Distutils, Setuptool
et Virtualenv.</p>
<p>Objectif :</p>
<ul>
<li>Comprendre l'intéret de ce type d'outil</li>
<li>Passer son projet Python sous Buildout</li>
<li>Développer avec Buildout</li>
<li>Déployer avec Buildout</li>
</ul>
<p>Contenu :</p>
<ul>
<li>Fonctionnement de Buildout</li>
<li>Ajouter des recettes</li>
<li>Déployer avec Buildout</li>
<li>Développement de recette</li>
</ul>
<h2>Les outils Devops en Python</h2>
<p><strong>Domaine</strong> : dév / <strong>Type</strong> : présentation  / <strong>Durée</strong>: : 2h</p>
<p>Depuis l'éclosion du mouvement Devops, des outils comme Chef ou Puppet sont
omniprésents et tiennent le haut du pavé. Mais du shell distribué aux outils de
déploiement en passant par le Cloud, il existe des outils de très bonnes
qualités en Python. Cette session est un tour d'horizon des outils disponibles
: Fabric, Ansible, Buildout, Salt...</p>
<p>Objectif :</p>
<ul>
<li>Connaitre les principaux outils en Python</li>
</ul>
<p>Contenu :
- Présentation de Fabric
- Présentation de Ansible
- Présentation de Buildout
- Présentation de Salt</p>
<h2>Présentation de Git</h2>
<p><strong>Domaine</strong> : dev / <strong>Type</strong> : présentation  / <strong>Durée</strong>: : 3h</p>
<p>Utilisateur de SVN pendant de nombreuses années, j'avais la sensation
croissante de me battre avec mon outil de travail. Pire, il s'adaptait très mal
à mes exigences collaboratives. De guerre las, nous en avons choisi un outil de
gestion de source décentralisé (Hg puis Git) début 2008. La différence était
flagrante, je me sentais comme libéré d'un poids qui me ralentissait, et la
production de l'équipe s'est fortement améliorée (quantitativement et
qualitativement). </p>
<p>Cette présentation vous donnera la compréhension nécessaire pour aborder
sereinement l'utilisation de Git (et aux DVCS en général) : La première partie
sera consacrée à la théorie, en passant en revue tous les concepts nécessaires
avec l'aide de nombreux schémas didactiques. Nous mettrons en pratique nos
nouvelles connaissances dans la seconde partie, en abordant les commandes qui
font la «différence», les workflows, l'utilisation de GitHub, le tout saupoudré
de conseils pour bien démarrer.</p>
<h2>Débuter avec Git</h2>
<p><strong>Domaine</strong> : dev  / <strong>Type</strong> : atelier  / <strong>Durée</strong>: : 5h</p>
<p>Vous voulez apprendre les bases de Git ? C'est session est pour vous. Mixant
théorie et pratique, cette sesion de 3 heures vous donnera les clés pour
comprendre cet outil fanstatique mais un peu rugueux à prendre en main.
Seront passés en revue les 3 concepts fondamendaux ainsi que les différentes
manipulations qu'offre Git. Nous terminerons par les commandes de base.</p>
<h2>Gérer le développment logiciel avec le Kanban</h2>
<p><strong>Domaine</strong> : management / <strong>Type</strong> : présentation / <strong>Durée</strong>: : 2h</p>
<p>Agiliste forcené depuis de nombreuses années mais non satisfait par
les outils de suivi de projet que j'employé jusqu'alors, j'ai décidé
de passer voici 5 ans, au développement par flux, représenté par l'outil
Kanban. </p>
<p>Objectif : </p>
<ul>
<li>Comprendre le développement par flux</li>
<li>Comprendre l'importance du <em>lead time</em></li>
<li>Etudier le fonctionnement d'un Kanban</li>
</ul>
<h2>Petit précis de management à l'égard des informaticiens</h2>
<p><strong>Domaine</strong> : management / <strong>Type</strong> : présentation  / <strong>Durée</strong>: : 3h</p>
<p>«Pourquoi devrais-je m'y connaitre en management ? je ne suis pas manager !».
Tel est la remarque que vous pouvez vous faire en lisant le titre.
Et pourtant, le management et l'organisation sont les 2 plus importantes
facettes du travail : remplacer «management» par <strong>gestion des hommes</strong> et
«organisation» par <strong>gestion des relations entre les hommes</strong> et vous comprendrez
qui est suicidaire de laisser cela à des prétendus managers, qui sans
aucune connaissance de leur métier prennent des décisions qui vous impactent
quotidiennement. Disposer d'une culture, même faible, permet de mieux comprendre
votre environnement et d'agir en conséquence.</p>
<p>Objectif :</p>
<ul>
<li>S'intéresser aux fonctionnement de son entreprise</li>
<li>Avoir une culture managérial et organisationnel</li>
</ul>
<h2>Je veux devenir un manager</h2>
<p><strong>Domaine</strong> : management / <strong>Type</strong> : présentation  / <strong>Durée</strong>: : 5h</p>
<p>A travers mes 7 ans d'expérience en tant que manager (et 8 en ayant subi des
managers), moi qui était au départ le stéréotype de geek seulement intéressé
par ma relation avec les ordinateurs, je vous propose un voyage initiatique
dans le monde fascinant du management.</p>
<h2>Objectif :</h2>
<p>Contenu :
- Le management, du 17eme siècle à nos jours
- Le mouvement Lean
- Le mouvement Agile
- System Thinking
- Monter une équipe
- La vision par flux
- Le Kanban</p>
<h2>Idées</h2>
<ul>
<li>Monter son premier IPBX avec Asterisk (atelier / 3h)</li>
<li>Présentation du langage Dart (présentation / 2h)</li>
<li>Introduction au lanagage Dart (atelier / 3h)</li>
<li>Debugguer du code Python (présentation / 1h)</li>
<li>Les libraires du développeur Python (présentation / 2h)</li>
<li>Apport du mouvement Lean dans le développement logiciel (présentation / 3h)</li>
<li>Apport du mouvement Agile dans le développement logiciel (présentation / 3h)</li>
<li>Monter une équipe de développement logiciel (présentation / 2h)</li>
<li>Développer une application réseau en Python avec 0MQ (atelier / 2h)</li>
</ul>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://douche.name/blog</uri>
    </author>
    <title type="html"><![CDATA[Les 5 niveaux de conscience d'un développeur]]></title>
    <link rel="alternate" type="text/html" href="http://douche.name/blog/2011/11/06/les-5-niveaux-de-conscience-d-un-developpeur" />
    <id>http://douche.name/blog/2011/11/06/les-5-niveaux-de-conscience-d-un-developpeur</id>
    <updated>2011-11-06T18:51:00Z</updated>
    <published>2011-11-06T18:51:00Z</published>
    <category scheme="http://douche.name/blog" term="coding" />
    <summary type="html"><![CDATA[Les 5 niveaux de conscience d'un développeur]]></summary>
    <content type="html" xml:base="http://douche.name/blog/2011/11/06/les-5-niveaux-de-conscience-d-un-developpeur"><![CDATA[<p>On peut juger un développeur sur la compréhension qu'il possède de son métier :
5 niveaux qui détermine bien souvent sa plus value pour une organisation.</p>
<h2>Niveau 0 : pisser de code</h2>
<p>Il pense que son boulot est de <strong>produire des lignes et des lignes et des lignes
de code</strong>. Généralement peu intéressé par ce qu'il fait, c'est juste un poste
qui paye la soupe. Ou alors c'est un boulot temporaire avant de passer chef de
projet.</p>
<p>Le développeur du niveau 0 se voit très fréquemment et forme le gros du bataillon
des SSII. Chaque fois qu'on le rencontre, on se pince les lêvres pour ne pas lui
demander pourquoi il fait ce métier. Mais il faut bien reconnaitre que c'est
souvent ce que lui demande son chef de projet...</p>
<h2>Niveau 1 : livrer du code</h2>
<p>Intéressé par la qualité du code, il pense qu'il doit <strong>livrer du code 
fonctionnel</strong>. Il s'intéresse aux <em>Design Patterns</em>, lit des livres sur le
développement logiciel, refactore de temps en temps son code pour le rendre
<em>plus beau</em> et s'intéresse aux tests.</p>
<p>Celui ci peut se rencontrer dans les groupes de développeurs, dans les soirées
consacrés aux codes... <strong>Il a souvent la passion de son métier</strong>. Il discute
longuement de code, et lit régulièrement blogs et livres sur le sujet.</p>
<h2>Niveau 2 : livrer un logiciel</h2>
<p>Le développeur <strong>livre un ensemble de code cohérent</strong>, qui possède une
structure et fonctionne comme un bloc uni. Il s'intéresse à la conception, à la
robustesse, à l'architecture logicielle. Il sait que les tests sont très
importants, autant unitaire que fonctionnel, avec une couverture suffisante
pour être rassuré quand il modifie des pans entiers du logiciel.</p>
<p>Le niveau 2 est plus rare. Trop souvent, à la question <em>quel est ton métier</em>,
un développeur me répond :</p>
<blockquote>
<p>Liver du code !</p>
</blockquote>
<p>Et non, ton métier est <strong>au minimum</strong> de livrer un logiciel. Avez vous déja
vu un client satisfait d'une livraison d'un dépôt Git ?</p>
<h2>Niveau 3 : livrer un produit</h2>
<p>Le développeur livre plus qu'un logiciel, <strong>il livre un produit</strong>. Il
s'intéresse donc à la couche système, aux procédures d'installation et de mise
à jour, à la reprise sur incident, à la mise en production. Il participe à la
documentation utilisateur et se met à la place des admins.</p>
<p>Livrer un produit signifie souvent l'abandon du travail d'intégration pour un
travail de conception, bien plus difficile. Il faut réfléchir avant
tout à <strong>ses problématiques</strong> (et non celles que le framework X à résolu pour
vous), au développement sur le long terme et donc à l'évolution du produit.</p>
<h2>Niveau 4 : livrer de la valeur</h2>
<p>Plus qu'un produit, même bien ficellé, le développeur apporte de la valeur.
Car le réel objectif est <strong>d'améliorer le business du client</strong>. Niveau ultime
et de loin le plus difficile car il demande de bien comprendre le métier du
client en plus de parfaitement maitriser le sein (le développement logiciel).</p>
<h2>Constat</h2>
<p>Je vous concède que c'est un poil schématique. Une des particularités quand
on travaille chez un éditeur logiciel est que le niveau minimum est... 4.</p>
<p>Le niveau 3 est malheureusement rare alors que c'est pourtant le niveau que tout
développeur devrait atteindre. Mais il faut bien avouer que le développement
logiciel est un métier à la fois très exigeant et nouveau (moins de 40 ans !).</p>
<p>L'autre raison que la plupart des développeurs travaillent en France dans le
service, et peu dans le monde de l'édition. Ce qui veut dire bien souvent
être en cascade (peu ou prou, même ceux qui disent faire de l'agilité, voir
mon article «l'agile est mort») avec un cahier des charges fixe. Il faut
une collaboration étroite avec le client pour échanger sur son business et
comprendre, au dela des besoins exprimés (qui sont le plus souvent des
solutions exprimées et non des besoins), les besoins réels et utiles. Ce qui
est rarement le cas en SSII ou la plupart des clients estiment que ce n'est
pas <strong>votre</strong> boulot de remettre en cause leurs besoins (comment voulez vous
ensuite que les développeurs se sentent conernés ?).</p>
<p>Je raconte souvent cette anectode :
En tant qu'éditeur, il nous a fallu pratiquement <strong>un an entre la première
version commerciale et la version crédible</strong>. Car nous avons trop misé sur
des clients et partenaires incapables d'exprimer clairement des besoins, ce qui
a affecté notre vision du produit. Nous avons donc sorti une version apportant
peu de valeur. C'est en rencontrant des partenaires spécialisés et connaissant
bien le métier que nous avons pu rectifier le tir et mieux comprendre ce dont
ils avaient besoin.</p>
<p>C'est évidemment de <strong>notre responsabilité</strong>, et je ne rejète en aucun cas la
faute sur des tierces personnes. Mais cela m'a bien un peu éloigné de la sainte
croyance <em>qu'il faut écouter le client</em>. Comme le disait Henry Ford :</p>
<blockquote>
<p>Si j'avais demandé à mes clients ce qu'ils voulaient, ils m'auraient réclamé
un meilleur cheval</p>
</blockquote>
<p>Au passage, c'est en rencontrant des partenaires et clients Suisses,
Belges, Allemands... (et non plus Français) que cela s'est amélioré :).</p>
<h2>Conclusion</h2>
<p>Etre éditeur logiciel, c'est être capable de livrer un produit robuste et
fiable rapidement. Il faut maitriser le développement logiciel de bout en bout
: le codage bien sûr mais aussi l'infrastructure, la conception, le packaging,
le déploiement, la production, la documentation, le support... Il faut être
foncièrement multi-compétences et vouloir s'améliorer dans tous ces domaines.
Mais ce qui rend le travail si intéressant et dur, c'est que vous devez
<strong>aussi</strong> maitriser votre coeur de métier. Là ou les niveaux 0 à 3 se
focalisent uniquement sur la technique (qu'elle soit système, réseau,
algorithmie, ihm, gestion de projet...)</p>
<p>C'est pour cette raison que les <em>livreurs de code</em>, même excellents, ne sont
bons au final, qu'a produire de la dette technique car plus intéressés par la
beauté d'un code que de trouver une finalité utile à celle ci.</p>
<p>Coder dans le cadre professionnel, ce n'est pas se faire plaisir avec le
pattern X ou la techno Y, c'est avant comprendre un métier et apporter le
maximum de valeur. Même si cela peut sembler inintéressant au premier abord,
livrer un produit fonctionnel, fiable et robuste, utilisé par des clients
heureux est le summum de la satisfaction, bien loin d'un algo lisible et
performant. C'est ce qui fait tout le charme du métier d'éditeur.</p>
<p>Mais ne me faites pas dire ce que je n'ai pas dit, il faut aussi se faire
plaisir en tant que développeur :).</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://douche.name/blog</uri>
    </author>
    <title type="html"><![CDATA[L'Agile est mort]]></title>
    <link rel="alternate" type="text/html" href="http://douche.name/blog/2011/08/08/l-agile-est-mort" />
    <id>http://douche.name/blog/2011/08/08/l-agile-est-mort</id>
    <updated>2011-08-08T03:00:00Z</updated>
    <published>2011-08-08T03:00:00Z</published>
    <category scheme="http://douche.name/blog" term="agile" />
    <category scheme="http://douche.name/blog" term="rumination" />
    <summary type="html"><![CDATA[L'Agile est mort]]></summary>
    <content type="html" xml:base="http://douche.name/blog/2011/08/08/l-agile-est-mort"><![CDATA[<p>Sous ce titre qui peut paraitre provocateur se trouve un constat plutôt amère,
d'autant plus amère que tout cela était prévisible depuis bien des années.
L'Agile est devenu <em>mainstream</em>, on en parle régulièrement dans les
journaux de décideurs (c'est bien la preuve de sa reconnaissance non ?), les
développeurs disent le pratiquer au quotidien, les responsables de projet
assurent en faire. Alors pourquoi ce pessimisme ? Parce qu'il ne se passe un
mois sans en avoir la preuve, par exemple quand quelqu'un se pose en face de
moi et me dit :</p>
<blockquote>
<p>L'agilité, c'est vraiment de la merde !</p>
</blockquote>
<p>Et cela m'arrive très souvent (certes ce n'est pas toujours aussi vulgaire).
Il ne faut pas 2 minutes pour savoir que son contexte n'est pas Agile, ni de
près, ni de loin. Mais le signe le plus tangible est d'entendre des
soit-disant <em>spécialistes</em> dirent n'importe quoi à longueur de blogs,
journaux ou listes de diffusion.</p>
<p>Oh, je vous vois venir : «mais qui es tu pour définir ce qui est de ce qui
n'est pas Agile ?». Excellente question ! En fait, si définir avec précision
les contours de l'agilité est difficile, surtout en 2011 où beaucoup de
pratiques ou de mouvements se disent Agile, il est bien plus facile de dire ce
qui n'est <strong>pas Agile</strong> quand c'est <strong>aux antipodes de la philosophie qu'il veut
incarner</strong>. Certes le référenciel des pratiques a augmenté, mais il y'a toujours des
fondamentaux clairs et bien visibles, et toutes pratiques agiles doivent en
découler. J'aime comparer l'agilité avec le Logiciel Libre,
deux mouvements auxquels je participe depuis longtemps (10 et 15 ans), car ils
sont dans les deux cas un mélange de technique et d'humain. Dans les deux cas,
c'est une certaine <strong>représentation du monde</strong> et des relations entre les
gens :</p>
<p>Si je diffuse un logiciel avec une licence Libre, par exemple BSD, mais que
je ne propose pas de bugtracker, de liste de diffusion, ou que je refuse toute
contribution extérieure, ou que j'obfusque mon code, ou que j'envoie sur 
les roses les demandes d'utilisateurs, je fais du Logiciel Libre (ma licence
le prouve) sur papier. Dans les faits, ce n'est qu'un ersatz, je ne respecte
pas la philosophie du Logiciel Libre. Il en est de même avec l'agilité.</p>
<p>A mes yeux, l'agilité se résume en trois points dont leurs présences sont
faciles à juger.</p>
<h2>La recherche de la valeur</h2>
<p>Souvent maladroitement appelé <em>un logiciel qui marche</em>, l'objectif est de 
donner aux utilisateurs un produit fonctionnel, utilisable et pratique.
Et sauf à produire un logiciel maintes et maintes fois demandée, c'est
une découverte, autant pour le client que pour l'équipe de développement.
C'est donc une utopie de croire que l'on peut définir à l'avance les
spécifications complètes du logiciel. Le but est avant de trouver ce
logiciel agréable et fonctionnel, et non de le faire vite. La cascade
est à bien des égards l'approche la plus efficiente pour faire du logiciel
rapidement :</p>
<ul>
<li>J'écoute les besoins.</li>
<li>Je conçois et valide les spécifications.</li>
<li>Je développe.</li>
<li>Je teste.</li>
<li>Je livre.</li>
</ul>
<p>Il n'y a pas plus rapide. Si vous faites depuis 20 ans la même chose, pas de
soucis. Je n'ai entendu que deux (oui deux, pas trois) sociétés
capables de livrer en temps et en heure avec de 99% succès en mode cascade.
Et sans surprise ce sont deux sociétés développant en Cobol sur une
plateforme assez ancienne des produits fortement similaires. En résumé :</p>
<ul>
<li>Equipe stable.</li>
<li>Techno et plateforme archi connues.</li>
<li>Métier fortement maitrisé.</li>
<li>Produits similaires.</li>
</ul>
<p>En sommes, un environnement idéal. Mais il est illusoire d'attendre d'un
client la capacité à définir avec précision ses besoins. Non seulement il
ne sait pas ce qu'il veut, mais il se rend souvent compte après coup que
ce qu'il a réussi à expliquer est sans intérêt ! Voire même que son business
ou ses besoins ont changés entre le début du développement et sa fin. Et je
ne parle même pas de la capacité d'une équipe de développement à livrer un
produit de bonne qualité d'une seule traite, surtout si c'est en découvrant
le métier du client. Bref, pour résumer, c'est utopique. Mettons cela sur
l'immaturité de notre métier, la jeunesse de nos outils et une formation
trop basique.</p>
<p>Au contraire, l'agilité se veut une quête de sens :</p>
<ul>
<li>Que dois je obtenir ?</li>
<li>Quelles sont les fonctionnalités réellement utiles ?</li>
<li>Ce besoin est il justifié ? N'est elle pas le symptôme d'un problème
  non technique ?</li>
<li>Voir même, ce logiciel est il utile ?</li>
</ul>
<p>C'est un effort collectif, allant du développeur jusqu'au client pour 
comprendre, analyser et développer de la valeur métier  à travers un
logiciel. Sans cela, vous faites de la cascade : on se met d'accord sur
une limite fonctionnelle, numéraire et temporelle et zou !</p>
<p>Passons au deuxième point.</p>
<h2>L'humain est au centre</h2>
<p>Ce qui ressort aussi est cette volonté permanente de mettre en
avant les personnes, et non les outils ou les processus. les seconds sont
aux services des premiers, et pas l'inverse ! Le développement est une
histoire de développeurs avant tout. Vous devez <strong>faire confiance aux gens,
les respecter dans leur capacité à produire, dans leur jugement</strong>. Cet accent
me semble t'il est absent des approches précédentes comme la cascade ou RUP.
Ces dernières sont plutôt axées processus, avec des dizaines de procédures
et de la documentation à profusion, le développeur n'étant qu'un rouage du
système.</p>
<p>CMMi est un bon exemple de cette vision : la documentation officielle parle
sempiternellement d'organisation et de processus. Et pire, il faut être
certifié CMMi pour savoir lire une doc CMMi (cherchez l'erreur) tellement elle
est inbitable et truffée d'une terminologie incompréhensible. D'ailleurs la
plupart font du cascade, c'est dire leur croyance dans les processus. Il
faudra attendre 2010 pour entendre le CEI parler sérieusement d'agilité, 11
ans après le livre de Ken Beck !</p>
<p>Au contraire, l'agilité privilégie l'interaction sur le processus, le
résultat sur la documentation, en rapprochant physiquement tous les
participants, en  poussant les réunions courtes mais régulières, et en
écoutant les gens.</p>
<p>Passons maintenant au troisième point.</p>
<h2>Le développement est une discipline</h2>
<p>Le développeur remis en selle comme moteur du développement, on lui demande
en échange de maitriser son métier : on veut du logiciel qui fonctionne ! Il
doit remettre sans cesse se remettre en cause, apprendre à faire mieux et à
affiner ses techniques de développement.</p>
<p>Le milieu logiciel aime bien se traiter d'artisan (chaque profession aime se
dépeindre avec élégance) mais cela est identique chez les livreurs, les
boulangers, les cuisiniers, les musiciens... Mis à part que le développement
logiciel est un métier non seulement très complexe mais en plus à ces
balbutiements : 60 ans. Cela est bien peu.</p>
<p>L'agilité apporte beaucoup de solutions intéressantes : le TDD, les tests,
la revue par les pairs, l'intégration continue ou le refactoring par exemple.
Bien sûr un développeur peut très bien travailler correctement depuis très
longtemps sans avoir jamais lu un seul livre sur l'agilité. Après tout Ken
Beck et ses accolytes ont découvert ces techniques, pourquoi pas les autres ?
Certes, mais se passer de l'agilité, c'est mettre de coté des années de
réflexion sur les pratiques de développement logiciel et ca serait bien
dommage.</p>
<h2>Alors, pourquoi dire que l'Agile est mort ?</h2>
<p>je ne suis malheureusement pas assez vieux pour savoir ce qui se passait dans
les années 70, 80 et 90 dans l'industrie du logiciel mais je ne crois pas me
tromper en disant que l'agilité est une étape marquante. Je suis malgré
tout un vieux Geek, j'achetais pas mal de livres sur la programmation voici 20
ans et je n'ai aucun souvenir des livres (en France en tout cas !) qui
ressemblaient peu ou prou à l'agilité, on apprenait plutôt en copiant le code
des <em>maitres</em> (en crackant des logiciels, en écoutant les démo-makers ou en
bavardant sur les BBS). Des pratiques quasi inconnues voici 10 ans sont
maintenant considérées comme des pratiques indispensables (vous faisiez
beaucoup de tests unitaires en 2000 ?).</p>
<p>L'agilité a <strong>apporté la lumière à des milliers de développeurs</strong>, dont moi,
et à fait progresser notre connaissance de notre métier, en construisant
pour la première fois un socle stable. Nous en sommes encore au début mais
nous tentons chaque jour de mieux comprendre ce métier Ô combien difficile.</p>
<p>Mais vous savez quoi ? <strong>Tout le monde s'en fout !</strong></p>
<h2>L'Agile est la nouvelle technique à la mode</h2>
<p>On s'aperçoit rapidement qu'une majorité d'organisations utilise l'Agile
parce qu'ils ont entendus que ça marche mais se foutent royalement de ce
qu'il y a dedans. Et pour cause, cela signifie aussi remettre à cause
deux visions fondamentales dans nos entreprises :</p>
<ul>
<li>
<p>L'informatique est un coût, pas un investissement.</p>
</li>
<li>
<p>Les employés sont interchangeables, et non le socle de l'entreprise.</p>
</li>
</ul>
<p>Ne voulant pas remettre en cause ces deux postulats, il ne peut en
résulter qu'un dévoiement du mouvement Agile. Et c'est ce qui se passe.
<strong>L'Agile est donc une mode</strong>, qui passe après le développement objet,
les Design Patterns, le C++, Java, les frameworks, RUP et quelques
autres. On verra dans quelques années fleurir de nouvelles modes quand les
promesses des vendeurs Agiles se seront écrasé sur le mur de la réalité
des entreprises.</p>
<h2>Mais que font ils ?</h2>
<p>Du développement <strong>itératif et incrémental</strong>. Ils découpent leurs
développements en lots plus petits, avec vérification régulière. Le rapport
avec l'Agile tel que je le décris au début du billet ? Aucun ! Faire
confiance aux gens ? Soyons sérieux, ils pratiquent régulièrement
le <em>command &amp; control</em>, technique qui consiste à faire travailler les
gens comme des marionnettes, et les accuser de faire du mauvais 
boulot en cas de pépin. Voir le développement comme une discipline ? Vous
parlez de ces directions des achats qui écrasent le prix journalier des
développeurs vers le bas ? Quand à la recherche de la valeur, cela
signifie remettre douloureusement en cause le fonctionnement de l'organisation.</p>
<p>Vous commencez à me comprendre ? Ce n'est d'ailleurs pas pour rien que l'on
vend du Scrum, qui consiste à faire des lots (appelé itération) avec démo
régulière qu'on soupoudre avec une réunion quotidienne et une rétrospective
de temps en temps. Le tour est joué, on fait de l'Agile !</p>
<p>Dites moi si ces quelques exemples vous dit quelques choses :</p>
<ul>
<li>
<p>Le Chef de projet est appellé ScrumMaster, parce qu'il a fait 2 jours de
  formation.</p>
</li>
<li>
<p>On n'évalue pas la pertinence business d'une fonctionnalité.</p>
</li>
<li>
<p>On a pris des développeurs sous qualifiés ou inexpérimentés car par chers.</p>
</li>
<li>
<p>Le pair-programming ou la revue de code ? Trop cher et inutile.</p>
</li>
<li>
<p>Le ScrumMaster assigne les tâches à chaque réunion quotidienne.</p>
</li>
<li>
<p>La rétrospective se fait avec le client.</p>
</li>
<li>
<p>Un cahier des charges est construit avant de développer.</p>
</li>
<li>
<p>On ne prend jamais le temps de revoir les parties qui posent problèmes.</p>
</li>
<li>
<p>On doit travailler tard pour rattraper le retard ou gérer les nouvelles
  demandes du marketing.</p>
</li>
<li>
<p>Le projet va dans le mur mais on ne fait rien.</p>
</li>
<li>
<p>On micro-manage les gens.</p>
</li>
<li>
<p>On découpe le projet en équipe qui ne se voit pas.</p>
</li>
<li>
<p>On ne fait pas monter en compétence les membres de l'équipe.</p>
</li>
</ul>
<p>Je pourrais ajouter bien d'autres exemples, mais vous voyez l'idée. Où est la
philosophie Agile ? Absente, car les organisations ne souhaitent pas changer
leur vision du développement logiciel, encore moins leur mode de fonctionnement.</p>
<h2>Pourquoi en faire ?</h2>
<p>Parce que ça se vend, pardi ! Des sociétés de conseils se sont placés sur
le marché, des associations se sont créés pour développer ce business. Alors
ca se vend, et plutôt bien maintenant.</p>
<p>Mais comment faire de l'Agile :</p>
<ul>
<li>
<p>dans un environnement <em>command &amp; control</em> ?</p>
</li>
<li>
<p>dans une culture du blâme et de la recherche du coupable, ou chaque
  responsable sort son parapluie au moindre soucis ?</p>
</li>
<li>
<p>quand on vous donne un cahier des charges sans remise en cause du besoin
  business ?</p>
</li>
</ul>
<p>En le triturant pour que cela rentre dans les cases. Un exemple ? La grande
<strong>tartuferie</strong> du développement Agile au forfait. Regardons de plus près : le
forfait consiste à définir une limite fonctionnelle, temporelle et numéraire
d'un développement. Cela vous rappelle quelque chose ? Pas pour rien que le
forfait agile est un serpent de mer dans toutes les conférences Agile depuis
des années, tous les responsables de SSII se demandant comment en faire.</p>
<h2>L'Agile est mort en 2001</h2>
<p>Plus précisemment en <strong>février 2001</strong>, à Snowbird Utah USA. C'est la
création du <em>Manifeste Agile</em> et de l'emploi du terme Agile. Plus généralement,
c'est une volonté de mettre en place un <strong>modèle</strong>, un cadre. C'est à partir
de 2002 que l'on voit fleurir les livres avec le terme agile dans le titre.</p>
<p>Cela peut paraitre surprenant de dire cela, puisque c'est aussi le début du
mouvement Agile. L'objectif de normaliser termes et principes, de les figer,
est avant tout pour mieux le vendre. Il est curieux de voir <strong>17 consultants
sur les 17 signataires du manifeste</strong> : tous vendent des livres, tous vendent
des formations. L'Agile Alliance fut créée dans la foulée pour en faire la
promotion. </p>
<h2>Un modèle sclérosé</h2>
<p>Résultat en 2011 ? Malgré quelques avancées, le discours Agile officiel est
proche de 2001. N'a t on rien appris en 10 ans ? Bien sûr que si : le
développement par flux, la prise en compte de l'organisation dans le
développement ne sont que deux  exemples fondamentaux. Mais pourtant, le modèle
Agile reste assez hémertique à ces changements. On a bien vu quelques
nouveautés mais rien de bien méchant. Pourquoi ? Parce qu'on est plus
intéressé à vendre qu'à réfléchir, car pour réfléchir <strong>il faut avant tout
faire</strong> ! Ce n'est pas en écrivant des livres et en faisant du consulting
qu'on peut produire. XP est le résultat de très nombreuses années de
pratique de développement logiciel. Taiichi Ono (fondateur du <em>Toyota
Production System</em>) à passé plusieurs décennies pour perfectionner son
organisation. Il ne faisait surement pas passer des certifications TPS 5 ans
après avoir débuté sa nouvelle organisation !</p>
<p>Il y a bien eu un déplacement léger du développeur vers l'organisation. Même
si le modèle Agile s'ouvre sur l'extérieur, cela reste limité : il suffit
de voir le rôle du <em>PO</em> (Product Owner), proxy du reste de la société, où
se trouvent des <em>stakeholders</em>. Ou est le marketing commercial ? Technique ?
La recherche de nouveaux marchés ? Le déploiement ? L'opérationnel ?
L'expérience utilisateur ? Le design ? En gros, où est tout le reste ?! 
Le vide, les têtes pensantes du modèle Agile sont encore à rabacher TDD et
planning poker, la belle affaire !</p>
<p>Pire, ce léger déplacement est contre balancé par le <strong>mouvement craftmanship</strong>,
qui se veut un retour au source, auto-centré sur le développeur. La seule
avancée intéressante vient de partir à l'eau ! Si vous voulez savoir pourquoi,
regardez juste le business du fondateur de mouvement, Bob Martin, vendeur
de livres et de formations... sur le code. Forcément, l'organisation, ce n'est
pas utile pour son business. Il est d'ailleurs marrant d'entendre certains se
pâmer devant ce mouvement comme ci c'était nouveau. XP disait peu ou prou la
même chose  voici 13 ans. Ce n'est d'ailleurs pas anodin que ce soit
majoritairement des Scrumistes qui ont font (en France) la promotion, alors
qu'ils critiquaient XP ouvertement.</p>
<h2>Conclusion</h2>
<p>J'espère avoir éclairci mon propos sur Twitter (140 caractères, c'est des
fois trop court :). Non, il ne faut pas arrêter de faire des tests,
du pair programming ou des réunions quotidiennes. Et non, il ne faut surtout
pas minimiser l'impact de l'agilité sur notre métier, bien au contraire ! Je
vous encourage à lire livres et blogs et à prendre ce dont vous avez besoin.</p>
<p>Il faut seulement avoir une vision systémique du mouvement, comprendre d'où
il vient, pourquoi il a été créé et pourquoi certaines personnes vendent le 
modèle Agile. Cela permet par exemple de comprendre le <em>Manifeste Agile</em>
au lieu de répéter bêtement son contenu qui est loin d'être optimal en 2011.
Cela permet aussi de comprendre que ce modèle créé en 2001 (Scrum en 96, XP
en 99) et qui a mis du temps à se propager n'apporte plus rien de neuf
depuis de nombreuses années. Si l'argent fut toujours le moteur, le modèle
est maintenant dévoyé <strong>pour rentrer dans la matrice consulting</strong>, loin des
objectifs initiaux. Et ni les voix <em>officielles</em> (Agile Alliance, Scrum
Alliance), ni ses <em>têtes pensantes</em> se sont élevés contre cela. Pire, elles
ont participé activement à ce dévoiement (qui a dit certification ?).</p>
<p>Je pourrais résumer ma pensée ainsi : <strong>L'agilité est une avancée importante,
mais le modèle Agile est inutile</strong>. C'est peut être le destin de tout
modèle. En tout cas il est temps que chaque organisation invente, à l'instar de
Toyota, son propre modèle de production. Un modèle <strong>adapté à son business, 
ses clients, ses collaborateurs</strong>. Un modèle qui <strong>prend en compte toutes les
nouvelles avancées</strong> que l'on peut trouver dans les mouvements tels que Devops,
Lean, Lean startup ou Kanban. Un modèle <strong>qui évolue</strong> sans cesse avec la
maturité et la capacité de l'organisation à produire.</p>
<p>Mais pour essayer de le faire sans relâche depuis 4 ans, je vous concède que
c'est bien plus difficile et pénible qu'une formation de 2 jours ou de
répéter à l'envie ce que l'on a lu dans un livre...</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://douche.name/blog</uri>
    </author>
    <title type="html"><![CDATA[Nouveau blog avec Blogofile]]></title>
    <link rel="alternate" type="text/html" href="http://douche.name/blog/2011/07/15/nouveau-blog-avec-blogofile" />
    <id>http://douche.name/blog/2011/07/15/nouveau-blog-avec-blogofile</id>
    <updated>2011-07-15T02:00:00Z</updated>
    <published>2011-07-15T02:00:00Z</published>
    <category scheme="http://douche.name/blog" term="python" />
    <category scheme="http://douche.name/blog" term="coding" />
    <summary type="html"><![CDATA[Nouveau blog avec Blogofile]]></summary>
    <content type="html" xml:base="http://douche.name/blog/2011/07/15/nouveau-blog-avec-blogofile"><![CDATA[<p>Cela faisait quelques temps que cela me titillait : écrire des billets avec
mon éditeur texte habituel, et de pousser en prod avec Git. C'est le blog
de <a href="http://gitfr.net/blog">#gitfr</a> qui m'a donné le courage de m'y mettre.
Et c'est maintenant chose faites. Adieu Wordpress, boujour Blogofile !</p>
<h2>Mais qu'utilises tu ?</h2>
<p>Un générateur statique de site, autrement un outil qui transforme les
documents textes (format <code>markdown</code> ou <code>rst</code>) en pages html, à l'aide de
templates.</p>
<p>Beaucoup d'avantages :</p>
<ul>
<li>Tout se trouve dans des fichiers textes.</li>
<li>Plus besoin d'être en ligne.</li>
<li>Ecriture avec Vim et non un éditeur WYSIWIG dans un navigateur.</li>
<li>Maintenance pratiquement nulle.</li>
<li>Plus de problème de sécurité.</li>
<li>Sauvegarde automatique sur GitHub.</li>
<li>Liberté totale sur l'organisation du site.</li>
<li>Hébergement simplifiée (plus besoin de PHP, Python...).</li>
<li>Et bien sûr, utilisation de Git pour gérer le site :).</li>
</ul>
<p>En contre partie, vous n'avez plus la facilité de créer un joli site en 2
clicks de souris. La, c'est à vous de créer votre template et de développer
les services supplémentaires (affichage de tweets par exemple).</p>
<h2>Un retour en arrière ?</h2>
<p>Je faisais du statique en 96 quand j'apprenais l'html 3 (ou 2 je ne sais
plus), et voila que je refais du statique en 2011, est ce vraiment
raisonnable ? Il y'a en fait un changement important qui permet ce retour
aux sources : le <strong>cloud</strong>. Pour disposer d'un blog, il faut un moteur de rendu
de billets, mais aussi un système de commentaires, la gestion de flux RSS,
le multi-compte, des droits et authorisations, etc.</p>
<p>Maintenant, vous pouvez externaliser tous les services importants :</p>
<ul>
<li>les commentaires : Disqus.</li>
<li>les flux RSS : Feedburner.</li>
<li>Suivi d'activité : Google Analytics.</li>
<li>Hébergement, backup, droit et travail collaboratif : GitHub.</li>
</ul>
<p>Cela permet de se concentrer sur l'essentiel : écrire du contenu.</p>
<h2>Organisation</h2>
<p>Il me faut deux dépôts. Pourquoi deux ? Ce n'est pas obligatoire bien sûr,
mais j'utilise le service d'hébergement gratuit de pages statiques de
<em>GitHub</em>. Ce dernier impose des contraintes, dont le nom du dépôt et
l'emplacement des fichiers. Si vous hébergé vous même le site, un seul dépôt
est suffisant.</p>
<p>Pour les utilisateurs de <code>Git</code>, les <em>submodules</em> font parfaitement
l'affaire puisque la version générée se trouve dans un sous répertoire.</p>
<h2>Un exemple ?</h2>
<p>La mise en production se fait comme suit :</p>
<pre><code>$ /path/to/blogofile/blogofile build
$ git add _site/*
$ git commit -m "nouveau billet sur Blogofile"
$ git push
</code></pre>
<p>(sans submodules, il suffit de copier le contenu manuellement).</p>
<p>Et voila ! Je vous laisse imaginer les possibilités intéressantes qu'offrent
un DVCS comme <em>Git</em> ou <em>Hg</em> (si ce n'est pas le cas, vous êtes bon pour voir une
de mes présentations Git ;) pour gérer votre site.</p>
<h2>Pourquoi Blogofile ?</h2>
<ul>
<li>
<p>Parce qu'il est en Python, et cela me permet de coder dans mon langage préféré
  et d'apprendre des moteurs de templates que je ne connaissais pas (<em>Mako</em> et
  bientôt <em>jinja2</em>).</p>
</li>
<li>
<p>Parce qu'il est vraiment simple. Pas fioritures, il va à l'essentiel. Ecrire
  des controlleurs ne semblent vraiment pas dur et les quelques fonctionnalités
  dont j'avais besoin (Disqus, flux RSS et blog) sont là. Un site de base tiens
  dans 700 lignes de code Python, ce qui rend la compréhension aisé. Blogofile
  fait pour sa part 900 lignes.</p>
</li>
<li>
<p>Il permet de gérer les documents drafts, le multi-auteur ou les
  transformations multiples.</p>
</li>
<li>
<p>Parce que je sature un peu de Ruby. Utilisant pas mal d'outils codés en
  Ruby ces derniers temps, je commençais en avoir ras la casquette des 
  erreurs d'installation ou des messages d'erreur complètement abscons. Mais
  des outils comme Jekyll ou Toto semblent pas mal du tout, j'ai fais joué
  ma fibre Pythonienne.</p>
</li>
</ul>
<p>Alors, si vous avez un site à monter, je vous conseille fortement de jeter un oeil
sur ces logiciels, cela peut vous intéresser ! :).</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://douche.name/blog</uri>
    </author>
    <title type="html"><![CDATA[Un retour sur Pomodoro]]></title>
    <link rel="alternate" type="text/html" href="http://douche.name/blog/2010/01/01/un-retour-sur-pomodoro" />
    <id>http://douche.name/blog/2010/01/01/un-retour-sur-pomodoro</id>
    <updated>2010-01-01T05:45:00Z</updated>
    <published>2010-01-01T05:45:00Z</published>
    <category scheme="http://douche.name/blog" term="lifehacking" />
    <summary type="html"><![CDATA[Un retour sur Pomodoro]]></summary>
    <content type="html" xml:base="http://douche.name/blog/2010/01/01/un-retour-sur-pomodoro"><![CDATA[<p>Cela fait maintenant plusieurs semaines que j'utilise la technique <a href="http://www.pomodorotechnique.com/">Pomodoro</a>, qui consiste (en gros) à découper le temps par tranche de 30 minutes : 25 minutes de travail puis 5 minutes de repos. D'abord trés sceptique, je suis devenu un partisan convaincu.</p>
<h2>Pourquoi tenter Pomodoro ?</h2>
<p>Au boulot, j'ai constaté une dégradation progressive de mon efficacité, c'est à dire de ma capacité à produire de la valeur. Je dois selon les moments trouver des idées, réfléchir à des actions ou tout simplement agir. Pire, j'endosse différents rôles bien différent les uns des autres, ce qui accentue la difficulté : les tâches n'ont aucune relation entre elles, demande un état d'esprit adpaté, des connaissances différentes... Bref,  ce n'est pas simple.</p>
<p>J'ai tenté plusieurs approches sans réussite comme jouer un rôle par jour : pas vraiment réaliste, on arrive vite à des situations de gachis extrême (exemple : tâches trop peu nombreuses pour la journée). Autre technique, la procrastination :). En gros, laisser courir le plus longtemps possible. Facile, mais pas efficace pour un sou. Bref, rien de convainquant, en retournant ça dans tous les sens, je n'ai guère le choix : abondonner certains aspects de mon travail ou trouver une méthode plus efficace. C'est la que j'ai tenté cette technique.</p>
<h2>Ce qui repousse à priori</h2>
<p>Le découpage en 25 minutes pardi ! "25 minutes, c'est bien trop court pour faire quoi que ce soit" est la première remarque qui vient à l'esprit. Ensuite le coté stressant de la chose, ce sentiment d'être minuté en permanence. Pas réjouissant. Enfin cet envie de repousser toute pratique qui demande à changer ses habitudes, surtout quand c'est 10 heures par jour... tous les jours.</p>
<h2>Un outillage adapté</h2>
<p>J'ai commencé par chercher une solution de chronométrage. L'idée d'avoir un chrono "physique" me semblait pas pratique, je ne me voyais pas en train de m'occuper du compteur régulièrement. J'ai donc cherché une version logicielle, fonctionnement bien sûr sous <em>Linux</em> (natif ou web).</p>
<p>Après quelques dizaines de minutes et plusieurs tests non concluants, je suis tombé sur <a href="http://www.workrave.org/welcome/">Workrave</a>. D'abord interloqué par la taille de l'engin (presque 7 Mo !), j'ai vite changé d'avis. Simple d'utilisation, il apporte quelques plus dont je n'avais pas imaginé en me lançant dans l'aventure :</p>
<ul>
<li>il bloque (option modifiable) le clavier pendant la pause, vous obligeant à vous arrêter. Cela semble ridicule mais quand on accepte difficilement de lâcher le clavier cela aide.</li>
<li>il affiche des exercices pendant la pause (je vous laisse deviner la tête de mes collègues :).</li>
</ul>
<h2>Les raisons du succès</h2>
<p>Mais alors, pourquoi cela marche ? Et bien c'est simple :</p>
<ul>
<li>il est difficile de garder sa concentration sur une longue période (les études disent souvent 45 minutes). Vous obliger à prendre une pause régulièrement vous rend plus efficace <strong>sur la journée</strong>.</li>
<li>la pause de 5 minutes n'est pas suffisamment longue pour vous rendre inefficace en reprenant le travail. Surtout que cette pause programmée ne vous déconcentre pas car <strong>vous arrêtez non pas par fatigue mais par choix</strong>. Et oui, en reprenant le travail, vous n'avez rien perdu de votre concentration, il ne faut pas 10 minutes pour reprendre le fil de vos pensées, mais seulement quelques secondes.</li>
<li>découper votre journée par tranche de 30 minutes ne veut pas dire que vous ne dépassez pas 30 minutes par tâches ! Rien ne vous interdit de passer 2 heures, ou 3, ou 4 ! Mais la, on voit <strong>le temps passer</strong>. On sait parfaitement que l'on vient de passer 2 heures sur ce foutu rapport car c'est la 4ème pause.</li>
<li>enfin, un avantage intéressant et non visible au départ et la possibilité de <strong>laisser passer un tour</strong>. Au mileu d'un travail j'ai envie de faire une pause, par exemple pour répondre à ce mail important ou alors lire Twitter. Au lieu de se sentir coupable de laisser une tâche, je me donne un tour (25 minutes) pour cela, en me disant que je reprendrais le travail aprés. Cela semble un poil stupide, mais ça marche pour moi.</li>
</ul>
<h2>Conclusion</h2>
<p>Voila un résumé sur l'avantage que je vois à Pomodoro. Il m'arrive encore d'oublier de lancer l'application le matin en arrivant au travail et je constate la différence. Pour moi c'est dorénavant jamais sans mon Pomodoro.</p>]]></content>
  </entry>
</feed>
